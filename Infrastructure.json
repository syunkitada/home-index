{"Entry":0,"TokenDocumentIndexMap":null,"IdTextMap":[{"Text":"# Infrastructure\n\n## Basic Contents\n\n| Link                                 | Description                                                                        |\n| ------------------------------------ | ---------------------------------------------------------------------------------- |\n| [Datacenter](datacenter.md)          | データセンタ                                                                       |\n| [DNS](dns.md)                        | DNS について                                                                       |\n| [DHCP](dhcp.md)                      | DHCP の仕組み(DHCPDISCOVER, DHCPOFFER, DHCPREQUEST, DHCPACK, DHCPNAK, DHCPRELEASE) |\n| [SMTP, POP, IMAP](smtp_pop_imap.md)  | STMP, POP, IMAP を踏まえ、メール送受信の仕組みについて                             |\n| [Security](security/README.md)       | セキュリティについて                                                               |\n| [Loadbalancer](loadbalancer.md)      | ロードバランサについて                                                             |\n| [ネットワークの Bonding](bonding.md) | ネットワークの Bonding、Channeling について                                        |\n| [電話網](telephone_network.md)       | 電話網について                                                                     |\n| [Words](words.md)                    | ネットワーク用語のメモ用                                                           |\n\n## 小ネタ リンク集\n\n- [Speed Test(cloudflare)](https://speed.cloudflare.com/)\n  - [about](https://speed.cloudflare.com/about/)\n- [Submarine Cable Map](https://www.submarinecablemap.com/)\n- [DeNA ライブ配信を支える技術と知識](https://engineer.dena.jp/2018/12/knowledge-for-livestreaming.html)\n- [The adj acency table Forwarding Information Base FIB](https://www.ccexpert.us/traffic-share/the-adj-acency-table-forwarding-information-base-fib.html)\n- [Forwarding Hardware](https://null.53bits.co.uk/index.php?page=forwarding-hardware)\n","UpdatedAt":"2021-03-15T21:55:34.673492+09:00"},{"Text":"# ネットワークの Bonding\n\n## サーバサイドでの Bonding(チーミングとも言う)\n\n- balance-rr (0)\n  - 送信の分散：ラウンドロビンで分散\n  - 受信の分散：スイッチに依存\n  - スイッチの制約：スイッチで EtherChannel を構成する必要がある\n- active-backup (1)\n  - 送信の分散: アクティブな NIC のみを利用\n  - 受信の分散: アクティブな NIC のみを利用\n  - スイッチの制約: なし\n- balance-xor (2)\n  - 送信の分散：MAC アドレスに基づいたハッシュで分散\n    - ルータ越しだと常に同じアダプタ\n    - ハッシュのポリシーは変更できる\n  - 受信の分散：スイッチに依存\n  - スイッチの制約：スイッチで EtherChannel を構成する必要がある\n- broadcast (3)\n  - すべての送信は、すべての NIC で行われる\n- 802.3ad (4)\n  - 送信の分散：MAC アドレスに基づいたハッシュで分散\n    - ルータ越しだと常に同じアダプタ\n    - ハッシュのポリシーは変更できる\n  - 受信の分散：スイッチに依存\n  - スイッチの制約：スイッチで 802.3ad を構成する必要がある\n- balance-tlb (5)\n  - 送信の負荷分散：負荷に応じてアダプタを選択\n  - 受信の負荷分散：アクティブなアダプタのみ\n    - アクティブなアダプタが故障すると別のアダプタが MAC アドレスを引き継ぐ\n  - スイッチの制約：なし\n- balance-alb (6)\n  - 送信の負荷分散：負荷に応じてアダプタを選択\n  - 受信の負荷分散：負荷に応じてアダプタを選択\n    - 通信相手の ARP テーブルを書き換えることでアダプタを選択（ARP ネゴシエーション）\n    - ルータ越しだと常に同じアダプタ\n  - スイッチの制約：なし\n\n## LAG(Link Aggregation)\n\n- 複数の物理リンクを束ねて 1 つの論理リンクとして扱うことのできる技術のこと\n- IEEE802.3ad で標準化され、Cisco では EtherChannel という用語を使用している\n- 設定方法は 2 つ\n  - スタティックにスイッチに設定する方法\n  - 各スイッチポートで論理グループを作成して、LACP(Link Aggregation Control Protocol)を使用してスイッチ間でネゴシエーションして動的に ON にする方法\n    - LACP は、IEEE802.3ad の標準プロトコル\n\n## vPC\n\n- Cisco の物理的に異なる 2 つの物理スイッチ間をポートチャネルで接続する技術\n- vPC を利用すると、STP によるブロッキングによって片方リンクを無効化する必要がなくなる\n- vPC 用語\n  - vPC\n    - vPC ピアスイッチによって形成されたポートチャネル\n  - vPC ピアスイッチ\n    - vPC プロトコルを実行し、vPC を提供するお互いの機器\n  - vPC メンバポート\n    - vPC を設定した vPC ピアスイッチ上の物理ポート\n  - vPC ピアリンク\n    - vPC ピアスイッチ間のポートチャネル\n    - vPC ピアスイッチ間で同期のために使用されるリンク\n    - ピアリンクを使用してローカルピアからの発信パケットとしてタグ付けする\n    - 対向の vPC ピアスイッチの vPC メンバーポートの障害発生時に、データトラフィックを導く\n  - vPC ピアキープアライブリンク\n    - リモートピアが正常に動作しているかどうかを判別する\"セカンダリテスト\"として使用される\n    - L3 通信パスを提供する\n    - このリンクではデータトラフィックや同期トラフィックは送信されない\n  - vPC ドメイン\n    - vPC を構成する 2 台の vPC ピアスイッチが所属するドメインのこと\n  - Cisco Fabric Services(CFS)\n    - ステートフルな設定メッセージの送受信と同期をサポートするよう設計されたプロトコル\n    - vPC ピアリンクでやりとりされる\n    - vPC ピアスイッチ間の状態の同期（MAC テーブル等）を行う\n","UpdatedAt":"2021-03-15T21:55:34.674499+09:00"},{"Text":"# Datacenter\n\n\n## 用語メモ\n* エリア・リージョン・アベイラビリティゾーン\n    * エリア\n        * 広いインフラのデータ管理\n            * 東日本エリア、西日本エリア、など\n        * エリアごとにインターネットゲートウェイが分離しており、エリア間でシステムを冗長化させたり、バックアップを授けることで、ディザスタリカバリ(DR)が実現できる\n    * リージョン\n        * エリアに属する地域・データセンタのくくり\n            * 東日本エリアの石狩、東日本エリアの東京、西日本エリアの大阪、など\n    * アベイラビリティゾーン\n        * リージョンに属するラックや電源系統などのくくり\n        * 電源系統を考慮してシステムを冗長化する場合に意識する\n* UPS(Uninterruptible Power Supply)\n    * 無停電電源装置\n    * 充電して繰り返し利用できる二次電池などを用いて電力を溜めておく装置\n    * メインの電源が何らかの事故で電力供給を受けられない場合に、一定時間にわたって一定の出力で電力供給を行う\n    * 対応可能な停電時間は数分から30分程度で、長時間の停電に対応するため発電機などを併用している\n        * メインの電源が落ちたときは、UPSで一時的電力供給をし、その間(数分程度)に発電機を稼働させて発電機から電力供給を行う\n        * データセンタには、発電機用の燃料がある程度蓄えられてるが、停電時には近場から燃料を供給してもらえるようにしている\n    * また、電源を冗長化させるため電力事業者から複数の回線を引くのが一般的\n    * 事例\n        * 2018年9月6日の北海道地震においての石狩データセンター\n            * https://www.publickey1.jp/blog/18/post_271.html\n            * 地震の影響で北海道電力からの電力供給がなくなり、UPSおよびディーゼル発電機により60時間近く稼働を続けた\n            * 石狩データセンターにはV12の1MWが6機、V16の1.5MWが5機の、計11機のディーゼルエンジンがあり、13.5MWの容量がある\n            * 備蓄燃料は70時間程度あり、節電運転する事で100時間程度が無給油で出来る状態にあった\n            * 燃料は重油を使っており、タンクローリーによってデータセンターへ運ばれ、データセンター内のタンクに備蓄される\n* PDU(Power Distribution Unit)\n    * PDUはUPSに接続されており、ラックごとに設置され、そのラック内の機器に電力供給を行う\n    * 電源を冗長化するため、複数の電力事業者から回線を引き、それぞれでUPSを用意して、PDUで各ラックに電力供給を行う\n    * PDUごとにブレーカがあり、過電流が起こるとそのPDU単位でブレーカトリップする\n    * システム構築者は各ラックに来ている電源系統を分散させるようにサーバを配置することで、電源の冗長性を得ることができる\n    * また機器によっては2系統のPDUから電力供給を受けることで、その機器自体で電源の冗長性を得る\n* エアーフロー\n\n\n## OSSのデータセンター管理ツール\n* openDCIM\n    * https://www.opendcim.org/\n    * デモサイト: https://www.opendcim.org/demo/index.php\n        * dcim\n        * dcim\n* rackTables\n    * https://www.racktables.org/\n    * デモサイト: http://demo.racktables.org/index.php?page=index\u0026tab=default\n        * admin:admin\n* netbox\n    * https://netbox.readthedocs.io/en/stable/\n\n\n## ベアメタルプロビジョニングツール\n* RackHD\n    * EMCがOSSで公開しているベアメタルプロビジョニングツール\n","UpdatedAt":"2021-03-15T21:55:34.6754961+09:00"},{"Text":"# DHCP\n\n- Dynamic Host Configuration Protocol\n- ネットワーク接続するのに必要な情報を自動的に割り当てるアプリケーション層プロトコル\n- UDP を使う\n- DHCP はもともと BOOTP(BOOTstrap Protocol)がもとになっており、メッセージ構造などはほぼそのまま\n  - BOOTP は単にクライアントに IP アドレスを通知するだけだったのに対して、DHCP では拡張部分を利用して、リース期間を設定したり、デフォルトゲートウェイの設定などもできる\n\n## 目次\n\n| Link                                          | Description |\n| --------------------------------------------- | ----------- |\n| [DHCP メッセージ](#DHCPメッセージ)            |             |\n| [初回リース時のフロー](#初回リース時のフロー) |             |\n| [リース延長時のフロー](#リース延長時のフロー) |             |\n| [DHCP リレー](#DHCPリレー)                    |             |\n| [DHCP の冗長化](#DHCPの冗長化)                |             |\n| [参考](#参考)                                 |             |\n\n## DHCP メッセージ\n\n- DHCP では、DHCP メッセージを UDP でやり取りする\n- ポート番号は、サーバ側が 67、クライアント側が 68\n- メッセージのオプション部分に、タグ番号で示される様々な種類のデータを設定できる\n\n| タグ値（10 進） | タグ名          | サイズ（オクテット） | 意味                                                                                   |\n| --------------- | --------------- | -------------------- | -------------------------------------------------------------------------------------- |\n| 1               | Subnet Mask     | 4                    | サブネット・マスク・アドレス                                                           |\n| 3               | Router          | 可変                 | デフォルト・ゲートウェイ・アドレス                                                     |\n| 6               | Domain Server   | 可変                 | DNS サーバ・アドレス                                                                   |\n| 12              | Hostname        | 可変                 | クライアントのホスト名                                                                 |\n| 15              | Domain Name     | 可変                 | DNS ドメイン名                                                                         |\n| 50              | Address Request | 4                    | クライアントがリクエストする IP アドレス                                               |\n| 51              | Address Time    | 4                    | IP アドレス・リース期間                                                                |\n| 53              | DHCP Msg Type   | 1                    | DHCP メッセージ・タイプ                                                                |\n| 54              | DHCP Server Id  | 4                    | DHCP サーバ・アドレス                                                                  |\n| 56              | DHCP Message    | 可変                 | DHCP エラーメッセージ                                                                  |\n| 58              | Renewal Time    | 4                    | クライアントがアドレスを取得してから Renewal（リースの再延長要求）するまでの期間（秒） |\n| 59              | Rebinding Time  | 4                    | クライアントがアドレスを取得してから Rebinding するまでの期間（秒）                    |\n\n- タグ「53」の DHCP Msg Type で、クライアント・サーバ間でメッセージ要求の意味を解釈している\n\n| 値  | メッセージ名   | 意味                                                                                    |\n| --- | -------------- | --------------------------------------------------------------------------------------- |\n| 1   | DHCPDISCOVER   | クライアントがサーバを「発見」するためのメッセージ                                      |\n| 2   | DHCPOFFER      | サーバからクライアントへの設定値「候補」を通知するメッセージ                            |\n| 3   | DHCPREQUEST    | クライアントが決定したサーバへの取得依頼メッセージ                                      |\n| 4   | DHCPDECLINE    | クライアントからサーバへの拒否（エラー）メッセージ                                      |\n| 5   | DHCPACK        | サーバからクライアントへの取得正常終了メッセージ                                        |\n| 6   | DHCPNAK        | サーバからクライアントへの取得拒否（エラー）メッセージ                                  |\n| 7   | DHCPRELEASE    | クライアントからサーバへのリリース要求メッセージ                                        |\n| 8   | DHCPINFORM     | IP アドレス取得は行わず、オプション取得のみ行う場合にクライアントから送られるメッセージ |\n| 9   | DHCPFORCERENEW | サーバからクライアントへの再構成要求                                                    |\n\n## 初回リース時のフロー\n\n- DHCP クライアント: DHCP DISCOVER をブロードキャストで送信する\n- DHCP サーバ: DHCP DISCOVER を受け取ったら、クライアントに対して DHCP OFFER(提案 IP を添えたレスポンス)を返す\n- DHCP クライアント: 一番最初に受け取った DHCP OFFER で提案された IP を払い出してもらえるように、DHCP REQUEST をブロードキャストで送信する\n- DHCP サーバ: サーバは要求に対して、IP の払い出しを承認する DHCP PACK を返す\n  - もしダメであれば、DHCP PNAK を返す\n- DHCP クライアント: PACK を受信したら IP アドレスなどの設定を行う\n  - PNAK の場合は、DHCP DISCOVER からやり直しとなる\n\n## リース延長時のフロー\n\n- DHCP PNAK で、クライアントには Address Time(リース期間)のほかに、Renewal Time、Rebinding Time が通知される\n- Renewal Time を過ぎるとクライアントは、IP の払い出したサーバにユニキャストで DHCP REQUEST を送信して、IP の延長(Renew)を行う\n  - 一般的に Renewal Time は、Address Time の半分で設定される\n  - Renew は成功するまで定期的に繰り返される\n- Renew が失敗し続け、Rebinding Time を過ぎるとクライアントは、DHCP DISCOVER をブロードキャストで送信して、IP の再取得(Rebind)を行う\n  - 一般的に Rebinding Time は、Address Time の 75%で設定される\n\n## DHCP リレー\n\n- DHCP を使うには同セグに DHCP サーバを設置する必要があるが、あるセグから他セグの DHCP サーバへ DHCP メッセージを仲介する「DHCP Relay」という仕組みがある\n- DHCP Relay はルータがサポートしている場合が多い\n\n## DHCP の冗長化\n\n- pacemaker などでアクティブ・スタンバイの構成にする\n- kubernetes などのオートヒールが可能なオーケストレーションツールを利用する\n- 設定すべき mac アドレス、IP アドレスが分かってれば、DB などで管理して、まったく同じ払い出しをする DHCP サーバをどうセグに複数台立てる\n\n## 参考\n\n- http://www.atmarkit.co.jp/ait/articles/0202/26/news001.html\n","UpdatedAt":"2021-03-15T21:55:34.6775171+09:00"},{"Text":"# DNS\n\n## 基礎\n\n- TODO\n\n## IPv6\n\n- TODO\n\n## スタブリゾルバ\n\n- リモートのリゾルバに毎回問い合わせするのではなく、ローカルにリゾルバを起動させてキャッシュさせる\n- ローカルのリゾルバの事をスタブリゾルバとも呼ぶ\n- スタブリゾルバがない場合\n  - 名前解決のたびにリモートへ問い合わせるので効率が悪い\n  - リモートの障害時に名前解決できなくなる\n- スタブリゾルバ一覧\n  - dnsmasq\n    - デフォルトは、127.0.0.1:53 でリッスンする\n    - /etc/resolv.conf などは手動で設定する必要がある\n  - systemd-resolved\n    - デフォルトは、127.0.0.53:53 でリッスンする\n    - systemd パッケージに含まれている\n    - /etc/resolv.conf は自動で設定される(シンボリックリンクが張られる)\n      - /etc/resolv.conf -\u003e ../run/systemd/resolve/stub-resolv.conf\n    - resolver は、以下のファイルで設定する\n      - /etc/systemd/resolved.conf\n      - /etc/systemd/resolved.conf.d/\n      - 編集したらリスタートする\n        - sudo systemctl restart systemd-resolved\n\n## メモ: PTR レコードの主な用途\n\n- 電子メールの受信拒否\n- 広告の表示(ジオロケーション)\n- SSH 接続の許可\n- ログファイル\n- Traceroute\n- サービスデスカバリ\n\n## セキュリティ関連の用語\n\n- DNS Cache Poisoning\n  - DNS(キャッシュ)サーバの脆弱性を利用して、偽のレコードを登録して攻撃する手法\n- DNS Rebinding\n  - DNS の返す IP アドレスを巧妙に変化させることにより、JavaScript などの same origin policy を破って攻撃する手法\n  - 攻撃者は、自分のコントロール可能なドメイン名を持っている、もしくは、ドメイン名を管理している DNS サーバを攻撃者が持っている必要がある\n  - DNS キャッシュサーバが間にあるとうまくドメイン名に紐ずく IP を変えることができないので、TTL を 0 もしくは非常に短くする\n- DNS Pinning\n  - ブラウザは毎回ドメインを解決するのではなく、ドメインを解決したらその結果を再利用することで、途中で IP アドレスが変更されることを防ぐ\n  - TTL の短いレコードを無視する場合もある\n\n## 参考\n\n- [DNS 再入門](https://www.slideshare.net/ttkzw/dnstudy-01-dnsprimer)\n","UpdatedAt":"2021-03-15T21:55:34.6788504+09:00"},{"Text":"# ip netns\n\n## ip netns で疑似的な calico like なネットワークを作る例\n\n- ゲスト(netns 内部) の IP を 192.168.50.X とする\n- ゲスト のゲートウェイには、リンクローカルアドレス(169.254.0.0/16) の 169.254.0.1 を利用する\n- arp に応答させるため、ホスト側の veth に proxy_arp を設定する\n\n### Setup netns1\n\n```\nsudo ip netns add testns\nsudo ip link add testns-ex type veth peer name testns-in\nsudo ip link set testns-ex up\nsudo ip route add 192.168.50.2 dev testns-ex\nsudo sysctl -w net.ipv4.conf.testns-ex.proxy_arp=1\nsudo sysctl -w net.ipv4.conf.testns-ex.forwarding=1\n\nsudo ip link set testns-in netns testns\nsudo ip netns exec testns ip addr add 192.168.50.2/32 dev testns-in\nsudo ip netns exec testns ip link set testns-in up\nsudo ip netns exec testns ip link set lo up\n\nsudo ip netns exec testns ip route add 169.254.1.1 dev testns-in\nsudo ip netns exec testns ip route add default via 169.254.1.1\n```\n\n### Setup netns2\n\n```\nsudo ip netns add testns2\nsudo ip link add testns2-ex type veth peer name testns2-in\nsudo ip link set testns2-ex up\nsudo ip route add 192.168.50.3 dev testns2-ex\nsudo sysctl -w net.ipv4.conf.testns2-ex.proxy_arp=1\nsudo sysctl -w net.ipv4.conf.testns2-ex.forwarding=1\n\nsudo ip link set testns2-in netns testns2\nsudo ip netns exec testns2 ip addr add 192.168.50.3/32 dev testns2-in\nsudo ip netns exec testns2 ip link set testns2-in up\nsudo ip netns exec testns2 ip link set lo up\n\nsudo ip netns exec testns2 ip route add 169.254.1.1 dev testns2-in\nsudo ip netns exec testns2 ip route add default via 169.254.1.1\n\n```\n\n### Accept Forword\n\n```\n# iptablesのFORWARD PolicyがDROPの場合は、ACCEPTに変更する\n$ sudo iptables -L | grep DROP\nChain FORWARD (policy DROP)\n\n$ sudo iptables -P FORWARD ACCEPT\n\n# もしくは許可する\n# iptables -A FORWARD -s ... -o ... -j ACCEPT\n```\n\n### Setup nat\n\n```\nsudo iptables -t nat -A POSTROUTING -s 192.168.50.2 -j MASQUERADE\nsudo iptables -t nat -A POSTROUTING -s 192.168.50.3 -j MASQUERADE\n```\n\n### Setup netsted netns\n\n```\nsudo ip netns add testnsvm\n\nsudo ip link add testnsvm-ex type veth peer name testnsvm-in\nsudo ip link set testnsvm-in netns testnsvm\nsudo ip netns exec testnsvm ip link set testnsvm-in up\nsudo ip netns exec testnsvm ip link set lo up\nsudo ip netns exec testnsvm ip addr add 192.168.60.1/32 dev testnsvm-in\nsudo ip netns exec testnsvm ip route add 169.254.1.1 dev testnsvm-in\nsudo ip netns exec testnsvm ip route add default via 169.254.1.1\n\nsudo ip link set testnsvm-ex netns testns\nsudo ip netns exec testns ip link set testnsvm-ex up\nsudo ip netns exec testns sysctl -w net.ipv4.conf.testnsvm-ex.proxy_arp=1\nsudo ip netns exec testns sysctl -w net.ipv4.conf.testnsvm-ex.forwarding=1\nsudo ip netns exec testns sysctl -w net.ipv4.conf.testns-in.proxy_arp=1\nsudo ip netns exec testns sysctl -w net.ipv4.conf.testns-in.forwarding=1\n\nsudo ip netns exec testns ip route add 192.168.60.1 dev testnsvm-ex\nsudo ip route add 192.168.60.1 dev testns-ex\n\nsudo iptables -t nat -A POSTROUTING -s 192.168.60.1 -j MASQUERADE\n```\n\n```\nsudo ip netns add testnsvm2\n\nsudo ip link add testnsvm2-ex type veth peer name testnsvm2-in\nsudo ip link set testnsvm2-in netns testnsvm2\nsudo ip netns exec testnsvm2 ip link set testnsvm2-in up\nsudo ip netns exec testnsvm2 ip link set lo up\nsudo ip netns exec testnsvm2 ip addr add 192.168.60.2/32 dev testnsvm2-in\nsudo ip netns exec testnsvm2 ip route add 169.254.1.1 dev testnsvm2-in\nsudo ip netns exec testnsvm2 ip route add default via 169.254.1.1\n\nsudo ip link set testnsvm2-ex netns testns2\nsudo ip netns exec testns2 ip link set testnsvm2-ex up\nsudo ip netns exec testns2 sysctl -w net.ipv4.conf.testnsvm2-ex.proxy_arp=1\nsudo ip netns exec testns2 sysctl -w net.ipv4.conf.testnsvm2-ex.forwarding=1\nsudo ip netns exec testns2 sysctl -w net.ipv4.conf.testns2-in.proxy_arp=1\nsudo ip netns exec testns2 sysctl -w net.ipv4.conf.testns2-in.forwarding=1\n\nsudo ip netns exec testns2 ip route add 192.168.60.2 dev testnsvm2-ex\nsudo ip route add 192.168.60.2 dev testns2-ex\n\nsudo iptables -t nat -A POSTROUTING -s 192.168.60.2 -j MASQUERADE\n```\n","UpdatedAt":"2021-03-15T21:55:34.6798551+09:00"},{"Text":"# IPv6\n\n## 概要\n\n- IPv4 と IPv6 は別物で互換性はなく、IPv6 対応とは両者デュアルスタック環境で運用するということ\n- DNS が IPv4 と IPv6 を返した場合にクライアントはどちらのプロトコルを使うかを選択する\n\n## IPv6 基本プロトコル\n\n- アドレスの種類\n  - ユニキャストアドレス\n    - 単一インタフェースの識別子\n    - ユニキャストアドレス宛のパケットは、そのアドレスをもつインタフェースに配送される\n  - エニーキャストアドレス\n    - インタフェースの集合の識別子で、複数の機器に付与される\n    - エニーキャストアドレス宛のパケットは、そのアドレスを持つ「一番近くにある」機器のインタフェースに配送される\n    - エニーキャストアドレスは、ユニキャストアドレス空間から割り当てられるので、表記上、エニーキャストアドレスとユニキャストアドレスの区別はつかない\n  - マルチキャストアドレス\n    - インタフェースの集合の識別子で、複数の機器に付与される\n    - マルチキャストアドレス宛のパケットは、そのアドレスをもつすべてのインタフェースに配送される\n    - IPv6 には、IPv4 にあったブロードキャストアドレスが存在せず、マルチキャストアドレスが同様の役割を果たす\n- アドレスの型\n  - IPv6 では、上位ビットにより、未指定アドレス、ループバックアドレス、マルチキャストアドレス、リンクローカルユニキャストアドレス、グローバルユニキャストアドレスに分類される\n- アドレスの表記法\n  - IPv4 アドレスは、32 ビットを 8 ビットずつ 4 つに\".\" (ピリオド)で区切った数値列を、\"192.168.0.1\" のように 10 進数で記述している\n  - IPv6 アドレスは、128 ビットを 16 ビットずつ 8 つに\":\" (コロン)で区切った数値列を、16 進数で表記する\n    - 例 ABCD:EF01:2345:6789:ABCD:EF01:2345:6789\n  - また、連続する 0 は省略が可能で、\"::\"は、16 ビットの 0 が複数連続していることを示す\n    - FF01:0:0:0:0:0:0:101 (マルチキャストアドレス)\n      - 省略型) FF01::101\n    - 2001:DB8:0:0:8:800:200C:417A (ユニキャストアドレス)\n      - 省略型) 2001:DB8::8:800:200C:417A\n    - 0:0:0:0:0:0:0:1 (ループバックアドレス)\n      - 省略型) ::1\n    - 0:0:0:0:0:0:0:0 (未指定アドレス)\n      - 省略型) ::\n- リンクローカルアドレス\n  - 同一リンク上でのみ有効なアドレスとして、リンクローカルアドレスが定義されている\n  - ノードは、少なくとも１つのリンクローカルアドレスを持つことが規定されているため、ノードをネットワークに接続するだけで、設定なしで同一リンク上の他のノードと通信が可能になる\n  - 応用\n    - BGP UNNUMBERED、OSPF UNNUMBERED\n      - BGP は TCP で、OSPF は OSPF で IP によって接続し、経路交換をする\n      - このとき、IPv4 では、自身の IP の設定が必要なのだが、IPv6 ではリンクローカルアドレスが自動で振られているので、設定不要で他のノードと経路交換が可能になる\n\n## ICMPv6\n\n## NDP(Neighbor Discovery Protocol)\n\n## IPv6 のアドレスの自動設定\n\n- SLAAC + RFC8106(RFC6106)\n- SLAAC + ステートレス DHCPv6\n- ステートフル DHCPv6\n\n## IPv6 とセキュリティ\n\n- IPv6 は新しいが、IPv4 よりもセキュアである刷毛ではない\n- むしろ新しく運用実績も少ないので、IPv4 よりもセキュリティについては劣るともいえる\n","UpdatedAt":"2021-03-15T21:55:34.6818521+09:00"},{"Text":"# Loadbalancer\n\n## Maglev\n\n- Google の開発した Software Loadbalancer(論文のみ)\n- https://storage.googleapis.com/pub-tools-public-publication-data/pdf/44824.pdf\n\n## katran\n\n- Facebook の開発した Software Loadbalancer(OSS)\n- https://code.fb.com/open-source/open-sourcing-katran-a-scalable-network-load-balancer/\n- https://github.com/facebookincubator/katran\n\n## GLB\n\n- Github の開発した Software Loadbalancer(OSS)\n- https://github.com/github/glb-director\n- https://githubengineering.com/glb-director-open-source-load-balancer/\n\n### GLB メモ\n\n- Router からの ECMP で L4 proxy hosts にリクエストを分散させる\n- L4 proxy hosts では、DPDK の PMD でパケット受け取り、glb-director が後ろの L7 proxy hosts にリクエストを転送する\n- glb-director は、リクエストの 5tuple からハッシングによって宛先を決めるが、この宛先 proxy を 2 台で 1 セット(primary/secondory)を一つの宛先として扱う\n  - 通常では、primary にのみパケットが転送される\n  - primary のホストがヘルスチェックのダウンや、明示的に drain で外そうとした場合、そのホストとペアになってるホストとで(primary/secondory)を入れ替える\n  - 新規のパケットは新しい primary ホストへ転送され、既存パケットは secondory へと転送され処理される\n- proxy では、パケットが到着したときに、そのパケットが新規パケットか、すでに Establish かをチェックしそうであれば自身で処理する\n  - そうでなければ、もう一つのペアあてのパケットとみなし、そちらにパケットを転送する\n  - もう片方でも扱ってない場合は破棄される\n    - ホップ数をカウントしているので、再度転送されることはない\n  - この転送の仕組みは glb-redirect iptables module で実現している\n    - GUE ヘッダ、Foo-over-UDP という技術を使ってる\n    - https://github.com/github/glb-director/blob/master/docs/development/gue-header.md\n\n## VPP\n\n- https://github.com/FDio/vpp\n- VPP 自体はユーザランドで動くパケットプロセッサ\n- LB プラグインを利用することで Maglev ライクな LB を実現できる\n\n## SRLB\n\n- https://www.thomasclausen.net/wp-content/uploads/2017/05/camera-ready-ieeepdfexpress.pdf\n\n## LINE の SWLB\n\n- https://www.slideshare.net/linecorp/ss-116879618\n- XDP を利用した Stateless L3DSR\n  - L3DSR は DSCP を利用した方式\n  - ICMP により L3DSR のヘルスチェックをしている\n- Verda の LBaaS として利用されてる?\n  - データプレーンは C(XDP)で 800 行\n  - コントロールプレーンは Python で 14000 行\n\n## Sticky ECMP\n\n- https://community.cisco.com/t5/service-providers-documents/xr-ncs5500-asr9000-persistent-loadbalancing-or-quot-sticky-ecmp/ta-p/3361883\n- 従来の ECMP はパスが消えると、経路がリハッシュされ既存のセッションも含めて経路が変わる可能性がある\n- Sticky ECMP はパスが消えた場合でも、その経路上のセッションのみ消えるだけで、既存のセッションには影響しない\n","UpdatedAt":"2021-03-15T21:55:34.6828545+09:00"},{"Text":"# 決済\n\n## リンク集\n\n- [【レポート】楽天の大規模決済システムを支える AWS アーキテクチャ #AWSSummit](https://dev.classmethod.jp/articles/aws-summit-online-2020-cus-65/)\n","UpdatedAt":"2021-03-15T21:55:34.6838516+09:00"},{"Text":"# Security\n\n| Link                                              | Description                          |\n| ------------------------------------------------- | ------------------------------------ |\n| [Basic](basic.md)                                 | 用語とか、メモとか                   |\n| [TLS](tls.md)                                     | TLS とか                             |\n| [SSH](ssh.md)                                     | SSH とか                             |\n| [Encription by openssl](Encription_by_openssl.md) | openssl を使ったファイルの暗号化方法 |\n","UpdatedAt":"2021-03-15T21:55:34.6873516+09:00"},{"Text":"# Basic\n\n## 脆弱性\n\n- 脆弱性とはソフトウェアやハードウェアに含まれるセキュリティ上の不備のこと\n- Exploit\n  - PC やスマートフォンの OS・ソフトウェアなどの脆弱性を悪用して攻撃を行うプログラムのこと\n- バッファオーバーフロー\n  - 特定のデータ構造の限界の外に書き込みを行ったとき、不適切な位置にデータを書き込み不正なコードを実行する\n  - メモリ管理がプログラマに任される C のコードでよく発見される\n- 脆弱性データベース\n  - 基本的には脆弱性の発見には脆弱性データベースを利用して発見することになる\n  - CVE(Common Vulnerabilities and Exposures)\n    - 脆弱性やインシデントについて、それぞれ固有の名前や番号を付与してリスト化したもの\n  - MITRE\n    - 米国政府の支援を受けた非営利団体の名称\n    - CERT/CC や、HP、IBM、OSVDB、Red Hat、Symantec などの脆弱性情報サイトと連携して、脆弱性情報の収集と、重複のない CVE の裁判に努めている\n  - CVE 互換認定\n    - 脆弱性検査ツールや脆弱性対策情報提供サービス等が、いくつかの機能要件を満たし、MITRE へ申請すると CVE 互換認定が受けられる\n    - 日本では、以下が CVE 互換認定を受けている\n      - [Japan Vulnerability Notes](http://jvn.jp/)\n      - [JVN iPedia](https://jvndb.jvn.jp/index.html)\n      - [MyJVN](https://jvndb.jvn.jp/apis/myjvn/)\n- 脆弱性の発見方法\n  - 脆弱性データベースは日々更新されるので、脆弱性はスキャンは単発ではなく、定期的にスキャンする必要がある\n  - 脆弱性スキャンは、Github などのソースリポジトリや、Dockerhub のようなイメージリポジトリにたいして行われる\n  - また、本番サーバ上のパッケージリストを定期収集しておいて、それをスキャンする手法もある\n  - 基本的な検査ツールではパッケージベースで脆弱性を検知するものが多く、tar などを展開してインストールされるものは検知できないものが多い\n- 参考\n  - [コンテナ・セキュリティ入門 脆弱性](https://qiita.com/MahoTakara/items/47d9c4ecd67f82977ca8)\n\n## 攻撃経路\n\n- リモートからの攻撃\n  - リモートユーザは最初にネットワークプログラムの脆弱性によって、そのプログラムの権限でコードを実行する\n    - また、必要に応じてより高い権限へ昇格してコードを実行する\n  - 対策\n    - 外部からアクセス可能なポートを制限する\n    - nginx や haproxy などのプロキシコンテナを前段においてネットワークプログラムを直接見せないようにする\n      - 攻撃者は、プロキシコンテナの脆弱性を突いたうえで、さらに奥のネットワークプログラムの脆弱性を突かなければならくなるため難易度が上がる\n    - ネットワークプログラムの権限を必要最低限に絞っておく\n      - 成功したエクスプロイトによる影響を抑えることができる\n      - また、root で起動して必要なパスワードなどの情報をメモリに保存した後、setuid を使って権限を降格する場合もある\n- 従業員端末からの攻撃\n  - 端末にメールなど何らかの方法でマルウェアを感染させて、そこから社内ネットワークに侵入して攻撃する\n    - メールの添付ファイルやリンクは不用意に開いてはいけない\n  - プライベートネットワークからの攻撃対策はおろそかになってる場合が多く注意が必要である\n- 仮想マシン上からの攻撃\n  - 仮想マシンは、ハイパーバイザ上で動作するため、ハイパーバイザプログラムや、CPU の脆弱性をつくことでハイパーバイザや、同居している仮想マシンへの攻撃が可能\n- Supply Chain Attack\n  - パッケージやイメージなどに含まれるライブラリなどに攻撃コードを仕込んで攻撃する手法\n  - インターネット上のパッケージやイメージやライブラリを利用している場合は、このような危険性をはらんでいる\n  - 対策が難しい\n\n## 攻撃ツール\n\n- 脆弱性の攻撃ツールや、bot net などは dark web や twitter で買うことができる\n- zero-day attack のみではなく、既存の脆弱性も警戒すべき\n","UpdatedAt":"2021-03-15T21:55:34.6888493+09:00"},{"Text":"# Encription by openssl\n\n- openssl enc [command] で暗号・複合を行うことができる\n- enc: Encoding with Ciphers の略\n\n```\n$ openssl version\nOpenSSL 1.1.1  11 Sep 2018\n```\n\n## 利用できる暗号化一覧\n\n```\n$ openssl enc -ciphers\nSupported ciphers:\n-aes-128-cbc               -aes-128-cfb               -aes-128-cfb1\n-aes-128-cfb8              -aes-128-ctr               -aes-128-ecb\n-aes-128-ofb               -aes-192-cbc               -aes-192-cfb\n-aes-192-cfb1              -aes-192-cfb8              -aes-192-ctr\n-aes-192-ecb               -aes-192-ofb               -aes-256-cbc\n-aes-256-cfb               -aes-256-cfb1              -aes-256-cfb8\n-aes-256-ctr               -aes-256-ecb               -aes-256-ofb\n-aes128                    -aes128-wrap               -aes192\n-aes192-wrap               -aes256                    -aes256-wrap\n-aria-128-cbc              -aria-128-cfb              -aria-128-cfb1\n...\n```\n\n## 暗号化・複合化\n\n```\n# $ openssl enc [cipher option] -in [input] -out [output] [options]\n\n# passwordは、-pass で指定するか、\n# 指定しない場合は、以下のように標準入力から入力する\n# -pbkdf2: Use password-based key derivation function 2\n$ openssl enc -e -aes-256-cbc -pbkdf2 -in hoge -out hoge.enc\nenter aes-256-cbc encryption password:\nVerifying - enter aes-256-cbc encryption password:\n\n# コマンドライン引数でパスワードを設定する場合は以下\n$ openssl enc -e -aes-256-cbc -pbkdf2 -in hoge -out hoge.enc -pass pass:hoge\nopenssl enc -aes-256-cbc -pbkdf2 -in hoge -out hoge.enc -pass pass:hoge\n\n\n# openssl enc -d [cipher option] -in [input] -out [output]\n$ openssl enc -d -aes-256-cbc -pbkdf2 -in hoge.enc -out hoge.enc.out\nenter aes-256-cbc decryption password:\n```\n\n## RSA を使っての暗号化・複合化\n\n```\n# 秘密鍵(private-key.pem)を作成\n## パスフレーズなし\n$ openssl genrsa -out private-key.pem\n## パスフレーズあり(aes256で暗号化)\n$ openssl genrsa -out private-key.pem -aes256\n\n# 秘密鍵(private-key.pem)から公開鍵(public-key.pem)を作成(パスフレーズが必要)\n$ openssl rsa -in private-key.pem -pubout -out public-key.pem\nEnter pass phrase for private-key.pem:\n\n\n# 公開鍵で暗号化\n$ openssl rsautl -encrypt -in hoge -out hoge.enc -inkey public-key.pem -pubin\n\n# 秘密鍵で複合化(パスフレーズが必要)\n$ openssl rsautl -decrypt -in hoge.enc -out hoge.enc.out -inkey private-key.pem\nEnter pass phrase for private-key.pem:\n\n\n# 秘密鍵で暗号化(パスフレーズが必要)\n$ openssl rsautl -encrypt -in hoge -out hoge.enc -inkey private-key.pem\nEnter pass phrase for private-key.pem:\n\n# 公開鍵で複合化\n$ openssl rsautl -encrypt -in hoge -out hoge.enc -inkey public-key.pem -pubin\n```\n\n## x509 証明書を使っての暗号化・複合化\n\n```\n# x509の公開鍵、秘密鍵を作成\n$ openssl req -x509 -nodes -newkey rsa:2048 -keyout private-key.pem -out public-key.pem -subj /CN=client.example.com\n\n# 公開鍵で暗号化\n$ openssl smime -encrypt -binary -aes-256-cbc -in hoge -out hoge.enc -outform DER public-key.pem\n\n# 秘密鍵で複合化\n$ openssl smime -decrypt -binary -in hoge.enc -inform DER -out hoge.enc.out -inkey private-key.pem\n```\n","UpdatedAt":"2021-03-15T21:55:34.689849+09:00"},{"Text":"# SSH\n\n## SSHv2\n\n- SSH サーバ接続後の流れ\n- 接続後、サーバとクライアントの間で SSH バージョン文字列を交換し，SSHv1 で接続するか，SSHv2 で接続するかを決定する\n- その後、使用できる鍵交換方式、希望する公開鍵暗号方式、共通鍵暗号方式、メッセージ認証コード、圧縮アルゴリズムのリストを交換する\n- このリストから、使用するアルゴリズムを決定し、Diffie-Hellman 鍵交換方式で暗号化通路に使用する共通鍵を交換する\n  - Diffie-Hellman 鍵方式は、交換するカギを直接送ることなく、両者で鍵を共有できるアルゴリズム\n- 共通鍵の交換中に、サーバのホスト公開鍵を、クライアントで保持しているホスト公開鍵のデータベースと照合して、ホスト認証もする\n  - 新規のホストであれば、データベースに登録するかを尋ねられ、クライアント側で登録を許可する必要がある\n  - データベースに登録済みであるホストであれば認証済みとする\n  - データベースに登録済みだが、公開鍵が異なっていた場合は不正なホストとみなして接続を停止する\n    - サーバを再インストールなどでホスト公開鍵を作り直した場合には、ssh-keygen -R [hostname] などでデータベースからいったんホスト情報を消す必要がある\n- 共通鍵を交換し終わったら、暗号化通信路を確立し、以降の通信は暗号化通信路で行われる\n- ユーザ認証を以下のどちらかで行う\n  - 公開鍵認証\n    - 各ユーザは自分の公開鍵・秘密鍵のペアを作っておく\n    - 各ユーザは自分の公開鍵をサーバ上になんらかの方法で以下に保存しておく\n      - /home/[user]/.ssh/authorized_keys\n    - 認証には電子署名を使う\n      - ユーザ名、ユーザの公開鍵、ユーザの公開鍵アルゴリズムを記述した認証要求メッセージを作成する\n      - この認証要求メッセージに対して、ユーザの秘密鍵を使用して電子署名を作成する\n        - 秘密鍵を作成する際にパスフレーズを設定してる場合は、この時にパスフレーズを要求される\n      - サーバに認証要求メッセージと電子署名を送信する\n        - これを ssh-agent に登録しておくことで、別ホストに ssh するさいにいちいちパスフレーズ入力をする必要がなくなる\n        - また、agent 転送することで多段 ssh が楽になる\n      - サーバは、認証要求メッセージに含まれるユーザ名、ユーザの公開鍵が、登録済みのユーザ名、公開鍵であることを確認する\n      - サーバは、登録されているユーザの公開鍵を使用して、送付された電子署名を審査し、正しいユーザの電子署名であることを確認できると、ユーザ認証成功とする\n  - パスワード認証(非推奨)\n    - ログインユーザのローカルパスワードによって認証する\n    - パスワードは暗号化通信路でやり取りされるので、第三者による観測はできない\n    - パスワードが漏洩しなければ問題ないが、パスワードが漏洩した場合にローカルパスワードも漏洩したこととなる\n    - このユーザが sudo password を利用していた場合、ssh されるだけでなく、root 権限の操作も可能となってしまう\n    - 多段 ssh もできないので不便（やりようによってはできるが、、、\n- ユーザ認証が成功したら、ターミナルのセッションが開始される\n","UpdatedAt":"2021-03-15T21:55:34.6916444+09:00"},{"Text":"# TLS\n\n## TLS(Transport Layer Security)とは？\n\n- 暗号化、認証のためのプロトコル\n- 元々は SSL(Secure Sockets Layer)という名前だったが、バージョンアップを重ねた後、SSL3.0 を元に TLS（Transport Layer Security）1.0 が RFC として定められた\n- その後、TLS が一般的に使われるようになったが、昔の名残で TLS のことを SSL や SSL/TLS と言ったりもする\n\n## 秘密鍵と公開鍵\n\n- 秘密鍵と公開鍵はペアで作られる\n  - 秘密鍵は特定の機器上にのみ持ち原則公開をしないもの\n  - 公開鍵は広く公開するためのもの\n- 暗号複合での用途\n  - 公開鍵は暗号化するためのもの、秘密鍵は複合するためのもの\n  - RSA など秘密鍵で暗号し公開鍵で複合することもできるものもある\n    - しかし、すべての公開鍵・秘密鍵がこの特性を持ってるわけではないので注意\n- デジタル署名での用途\n  - 秘密鍵は署名するためのもの、公開鍵は署名が正しいかを検証するためのもの\n  - 署名と検証は秘密鍵による暗号化と公開鍵による複合が必要となる\n\n## ハッシュ関数によりデータが改ざんされていないことを保証するということ\n\n- ハッシュ関数は、任意の入力データから固定の値を得るための関数\n  - この値をダイジェスト（もしくはハッシュ値）と呼ぶ\n- このダイジェストが変わらないことでデータが改ざんされていないことを保証できる\n\n```\n$ echo hoge \u003e hoge\n$ md5sum hoge\nc59548c3c576228486a1f0037eb16a1b  hoge\n\n$ echo piyo \u003e hoge\n$ md5sum hoge\n5ac5ee93bec2a712250aefed8f7568e7  hoge\n```\n\n## MAC（メッセージ認証コード）\n\n- MAC（メッセージ認証コード）では署名と検証するための鍵が同じ\n- 入力データと秘密鍵（適当な文字列でよい）をハッシュ関数に通して、ダイジェストを生成する\n  - このダイジェストが署名となる\n- この署名が正しいかを検証するには、入力データと秘密鍵をハッシュ関数に通して、生成されたダイジェストが署名と一致すれば改ざんされていないことを証明できる\n  - この証明ができるのは秘密鍵を知っているもののみである\n\n## デジタル署名(電子署名)\n\n- 一般的なデジタル署名は特殊な公開鍵・秘密鍵を用いるもので、秘密鍵で署名し、公開鍵で検証する\n  - 特殊な公開鍵・秘密鍵というのは、RSA のように秘密鍵で暗号化し、公開鍵で複合できる必要があるということ\n  - ここで重要なのは秘密鍵をもっている本人のみが署名を作れることを保証し、公開鍵を持ってる人が（誰でも）署名の検証ができるということ\n    - その手段として、秘密鍵で暗号、公開鍵で複合できると、これが満たせる\n- デジタル署名を含むデータ送信の流れ\n  - データ送信側: 秘密鍵と公開鍵のペアを作る\n  - データ送信側: 何らかの方法で相手に公開鍵を送信する\n  - データ送信側: 対象データを用意する\n  - データ送信側: 対象データをハッシュ関数でダイジェストを生成し、これを秘密鍵で暗号化する（これがデジタル署名)\n    - ダイジェストを生成するのは、データ長を短い固定長にするため（計算コストを下げる目的がある）\n  - データ送信側: 対象データと署名を相手に送信する\n  - データ受信側: 公開鍵を用いて、デジタル署名を複合する\n  - データ受信側: 対象データのダイジェストと、複合された署名が一致することを確認する\n- 以上の流れにより、データが改ざんされていないこと、データの送信者が公開鍵の秘密鍵を所持していることを保証できる\n\n```\n# 秘密鍵の作成\n$ openssl genrsa -out private-key.pem\n\n# 公開鍵の作成\n$ openssl rsa -in private-key.pem -pubout -out public-key.pem\n\n# 対象データを用意\n$ echo hoge \u003e hoge\n\n# 秘密鍵により署名を作成\n$ openssl dgst -sha1 -sign private-key.pem hoge \u003e sign.sig\n\n# 公開鍵により署名を検証\n$ openssl dgst -sha1 -verify public-key.pem -signature sign.sig hoge\nVerified OK\n\n# 公開鍵により署名を検証(NG例)\n$ openssl dgst -sha1 -verify public-key.pem -signature sign.sig piyo\nVerification Failure\n```\n\n## CSR と証明書チェーン\n\n- CSR(Certificate Signing Request)\n  - 認証局(第三者)に公開鍵の証明書を発行してもらうためのリクエスト\n  - サービス提供者は、CSR を用いて事前に認証局から証明書を発行してもらう\n  - ある公開鍵を証明するための認証局とは別に、その認証局の公開鍵を証明するための認証局も存在する\n- 証明書チェーンは公開鍵を本物かどうかを検証するための仕組み\n- 事前準備\n  - サービス提供者 A は、認証局 B に A の公開鍵の証明書(サーバ証明書)を発行してもらう\n    - 証明書には以下の情報が含まれる\n      - 主体者: A\n      - 発行者: B\n      - 公開鍵: A の公開鍵\n      - 署名: B によるデジタル署名\n  - 認証局 B は、認証局 C に B の公開鍵の証明書(中間証明書)を発行してもらう\n    - 証明書には以下の情報が含まれる\n      - 主体者: B\n      - 発行者: C\n      - 公開鍵: B の公開鍵\n      - 署名: C によるデジタル署名\n  - 認証局 C は、自身の公開鍵の証明書(ルート証明書)を発行しておく\n    - 証明書には以下の情報が含まれる\n      - 主体者: C\n      - 発行者: C\n      - 公開鍵: C の公開鍵\n      - 署名: C によるデジタル署名\n    - ルート証明書は主体者と発行者が同じである\n    - 主要なブラウザや OS には事前にルート証明書がインストールされているため、クライアントは何もせずともルート証明書を所持している\n      - またルート証明書は、OS のアップデートやブラウザのアップデート時に自動で更新される\n    - また、独自のルート証明書を利用する場合は、独自にそのルート証明書をブラウザや OS にインストールする必要がある\n- 証明書チェーンの流れ\n  - サーバはクライアントに A のサーバ証明書を送信する\n    - サーバ証明書の署名は B によってなされたもので、これを検証するためには B の公開鍵が必要となる\n  - 認証局 B の公開鍵付きの証明書をもらう\n    - この証明書の署名は C によってなされたもので、これを検証するためには C の公開鍵が必要となる\n  - C の公開鍵はルート証明書としてあらかじめインストールされているので、証明書の検証ができる\n  - 以上の流れにより、サーバ証明書に含まれる A の公開鍵の妥当性を証明することができる\n  - このようなサーバ証明書の妥当性を検証するまでを証明書チェーンと呼ぶ\n- 証明書チェーンによってサーバ証明書の認証が完了すれば、クライアントはその公開鍵を使って目的のデータを暗号化してサーバにデータを送信することができる\n  - この暗号化されたデータを複合できるのは当然秘密鍵を持ったサーバのみである\n- 補足としてサーバ証明書を管理するのは厳密にはサーバではない\n  - 正しくは、クライアントと TLS を実際に終端するもの(直接コネクションを確立するもの)が管理する\n  - サーバが管理する場合もあるし、インラインロードバランサが管理する場合もあし、また SSL-VPN では、VPN のゲートウェイが管理する\n- サーバ証明書の有効期限について\n  - サーバ証明書にはその有効期限を設定することができる\n  - ブラウザによってはサーバ証明書の有効期限が長すぎると警告が出たり、はじかれる場合があるため、有効期限は 1 年以内にすることが推奨とされている\n    - これは Safari が 2020 年 9 月より、それ以降に発行されたサーバ証明書において有効期限が 399 日以上のサーバ証明書を信頼できないものと表示するようにしたため\n  - 公開鍵からも膨大な時間を掛ければ秘密鍵を推測することは可能なため、証明書は定期的に更新し続けるべきである\n  - ただし、公開鍵を不特定多数に公開していない場合、例えばプライベートなネットワーク空間や開発環境で利用している場合は、多少長くしてもよしとされている\n    - とはいえ、証明書の定期更新の仕組みは今や必須である\n\n## HTTPS\n\n- HTTPS コネクションの確立時の流れ\n  - クライアントが https のサーバにアクセスしたときに、SSL 暗号化通信で接続を要求する\n  - サーバは、自身を証明するサーバ証明書をクライアントに送る\n  - クライアントは証明書チェーンにより、サーバ証明書が正しいことを確認する\n  - クライアントはサーバ証明書に含まれる公開鍵を使って、プライマスタシークレットを暗号化してサーバに送信する\n    - プライマスタシークレットとは共通鍵を生成する元となる乱数データのこと\n      - これによりクライアントは共通鍵を生成する\n  - サーバは暗号化されたプライマスタシークレットを複合化し、共通鍵を生成する\n  - 以降のセッションは共通鍵によって暗号化された通信経路上で行われる\n\n## X.509 証明書\n\n- デジタル証明書のデータ形式を定めた規格の一つ\n- 証明書のデータ表現\n  - 証明書の構造は、[RFC 5280](https://tools.ietf.org/html/rfc5280) で定められている\n  - ASN.1 で定義されているが、ASN.1 自体はデータ構造を抽象的に表現するための記法なので、この定義だけでは具体的にどのようなバイト配列にデータを落とし込めばよいのかは定まらない\n  - 具体的なバイト配列に落とし組むための技術仕様が別途必要となり、これは以下などがある\n    - DER(Distinguished Encoding Rules)\n    - XER(XML Encoding Rules)\n    - JER(JSON Encoding Rules)\n  - DER などでバイト配列に落とし込んだらこのまま使ってもよいが、この後に、BASE64(RFC 4648)などのデータ形式に変換することもある\n  - さらに、BASE64 でテキストデータになったら、これを PEM(RFC 7468) という形式でデータ修飾してもよい\n    - PEM は、data を ----BEGIN CERTIFICATE---- data -----END CERTIFICATE----- でくくったやつ\n    - よく見かける証明書ファイルは人が読みやすいよう PEM で吐き出される\n- 主体者識別子\n  - Subject: ホスト名で主体者をしていするためのもの\n  - SubjectAlternativeName: ホスト名以外で主体者名を指定するためのもの\n\n## TLS サーバ証明書(サーバ ID)\n\n- 大きく分けてドメイン名認証型と企業認証型の２つがある\n  - ドメイン名認証型(DV)\n    - ドメインの所有者と証明発行を申し込んできた運営者が同一であることを確認してから発行される\n    - 身元確認はしないので、実在性は証明しない\n  - 企業認証型(OV)\n    - DV の確認に加えて、帝国データバンクや登記事項証明書の確認、電話による申請者の在籍・役職と申請の意思確認などが行われから発行される\n  - 企業認証型(EV)\n    - OV の確認に加えて、事業所の実在性の確認と事業所への申請責任者確認書の送付・返送が必要などが行われてから発行される\n- TLS 証明書は認証局に発行してもらうものだが、独自にサーバ証明書を発行することもできる\n- TLS 証明書の信頼性は、EV \u003e OV \u003e DV \u003e 独自 となる\n- TLS 証明書には、以下のような情報が含まれる\n  - 公開鍵\n  - 有効期限\n  - Subject: CommonName\n    - サーバのホスト名を設定する(必須)\n    - クライアントがアクセスした際に URL と、Subject が一致しているかを検証します\n  - Subject: Alt Name\n    - Subject の別名を複数設定できる(オプション)\n  - Server Certificate:\n    - その証明書を発行した認証局の証明書、さらに上位の認証局があればそれも（ルート証明書までの証明書チェーン)を含む\n\n## 自己証明書の作成\n\n- [cfssl](https://github.com/cloudflare/cfssl)\n  - 使用例: [Provisioning a CA and Generating TLS Certificates](https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/master/docs/04-certificate-authority.md)\n\n## CAA レコード\n\n- SSL/TLS 証明書の発行を許可する認証局を、ドメインの所有者が宣言するためのレコード\n- 認証局は、証明書発行の際に、subjectAltName に記載されたドメインすべての CAA レコードをチェックすることが義務付けられており、証明書の不正発行や誤発行を防ぐ役割がある\n\n```\n;; ANSWER SECTION:\ngoogle.com.             86400   IN      CAA     0 issue \"pki.goog\"\n\n;; ANSWER SECTION:\nyahoo.co.jp.            900     IN      CAA     0 issue \"globalsign.com\"\nyahoo.co.jp.            900     IN      CAA     0 issue \"digicert.com;cansignhttpexchanges=yes\"\nyahoo.co.jp.            900     IN      CAA     0 iodef \"mailto:nic-admin@mail.yahoo.co.jp\"\nyahoo.co.jp.            900     IN      CAA     0 issue \"cybertrust.ne.jp\"\n```\n","UpdatedAt":"2021-03-15T21:55:34.6931777+09:00"},{"Text":"# SMTP, POP, IMAP\n\n## Contents\n\n| Link                                                              | Description                                              |\n| ----------------------------------------------------------------- | -------------------------------------------------------- |\n| [SMTP と POP3 と IMAP4](#smtp%E3%81%A8pop3%E3%81%A8imap4)         | STMP, POP3, IMAP4 を踏まえ、メール送受信の仕組みについて |\n| [Web メールと IMAP](#web%E3%83%A1%E3%83%BC%E3%83%AB%E3%81%A8imap) | Web メールについて                                       |\n| [用語メモ](#%E7%94%A8%E8%AA%9E%E3%83%A1%E3%83%A2)                 | ただの用語メモ                                           |\n\n## SMTP と POP3 と IMAP4\n\n- SMTP=Simple Mail Transfer Protocol\n  - メールサーバにメールを送信するためのプロトコル\n  - ポート番号は 25、サブミッションポートとして 587 も利用可能\n  - SMTP over SSL のポート番号は 465\n- POP3=Post Office Protocol version 3\n  - メールサーバからメールを受信するためのプロトコル\n    - メールはメールクライアントソフトに保存され、振り分けなどの処理を行う\n  - ポート番号は 110\n  - POP over SSL のポート番号は 995\n- IMAP4=Internet Message Access Protocol version 4\n  - メールサーバからメールを参照するためのプロトコル\n    - メールはサーバ側に保存され、振り分けなどの処理も行ってくれる\n    - メールクライアント側の消費リソースが少なくて済むため、スマホなどで利用される\n  - ポート番号は 143\n  - IMAP over SSL のポート番号は 993\n- 2 つの使われ方がある\n  - 一般ユーザがメールクライアントを利用して、SMTP サーバにメールデータを送信する\n  - SMTP サーバから別の SMTP サーバに対してメールデータを送信する\n- シンプルなメール送受信処理の流れ\n  - メール送信者は SMTP を使って SMTP サーバにメールを送る\n  - メール受信者は POP3 や IMAP4 を利用して POP3 サーバ(もしくは IMAP4 サーバ)からメールを受け取る\n  - このとき、メール送信者とメール受信者が利用するメールサーバは同一でないといけない(@以降のドメイン部分が一緒である必要がある)\n  - また、基本的に SMTP サーバ、POP3 サーバ、IMAP4 サーバは同居しており、これらを合わせてメールサーバと呼ぶ\n  - メール送信者とメール受信者のドメインが違う場合\n    - メール送信者は SMTP を使って自身の設定しているメールサーバにメールを送る\n    - そのメールサーバは、SMTP で目的のドメインのメールサーバにメールを転送する\n    - そして、メール受信者は自身の設定しているメールサーバから POP3 でメールを受信する\n- メール送信処理の流れ\n  - メールクライアントは、メールクライアントに設定されている SMTP サーバに SMTP 接続する\n    - 認証の仕組み(SMTP-AUTH)\n      - SMTP サーバに接続すると、サーバからは認証情報要求をされるので、メールクライアントは ID・パスワードを送付する\n      - SMTP サーバは、LDAP などで受信したアカウントが正しいかを確認する\n    - 認証の歴史\n      - 認証がなかった時代は、みなが好き勝手にメールを送れたため、スパムメールが流行した\n      - その対策として POP before SMTP(POP は認証機能がついてるので、SMTP をする前に POP で認証していた)\n      - その後、SMTP-AUTH が主流となった\n  - 認証が成功したら、メールソフトから SMTP サーバにメールが送信される\n  - SMTP サーバは自身のドメイン宛てであれば自身のメールスプールサーバに保存し、そうでなければ目的のドメインへの SMTP サーバへ転送する\n    - 最後に、メール受信者は、POP3 や IMAP4 でメールスプールサーバからメールを受信する\n  - 他の SMTP サーバへの転送の流れ\n    - SMTP サーバは DNS サーバへ MX レコードを問い合わせる\n      - SMTP サーバはメールを受信したら、宛先メールアドレスの@以降のドメインネームの MX レコードを DNS サーバに問い合わせる\n        - これにより、宛先メールアドレスのメールサーバの IP アドレスを取得できる\n    - その IP アドレス宛てに SMTP でメールを転送する\n    - このとき、メールを受け取った側の SMTP サーバは、送り元の SMTP サーバの MX レコード、逆引きレコードを DNS サーバに問い合わせ、送り元が正しいか検証する\n- メール受信処理の流れ\n  - メールクライアントは、メールクライアントに設定されているメールスプールサーバ(POP サーバ、もしくは IMAP サーバ)の IP アドレスにメールの受信要求とアカウントの ID パスワード情報を送る\n  - メールスプールサーバは、LDAP などでアカウントの認証を行い、認証がとおれば、メールを受信できる\n\n## Web メールと IMAP\n\n- Web メールとは Web ブラウザなどから利用できるメールのこと\n- Web サーバは、ユーザにメールクライアントの WebUI を提供している\n- Web サーバの裏ではメールサーバに対して IMAP でメール参照したり、SMTP でメールを送信している\n\n## 用語メモ\n\n- メールクライアントのことを MUA(Mail User Agent)と呼ぶ\n- メールサーバのことを MTA(Mail Transfer Agent)と呼ぶ\n","UpdatedAt":"2021-03-15T21:55:34.6945335+09:00"},{"Text":"# 電話網\n\n## 歴史\n\n- 交換手の時代\n  - 電話と電話の間に「交換手」と呼ばれる人がいて、その交換手が配線を切り替えて電話とつなげていた\n  - ダイヤルがなく、受話器を上げると交換手に繋がり、「だれだれにつなげてください」と告げると交換手がつなげてくれる\n- 自動交換機の時代\n  - 1926 年から徐々に「交換手」に代わる「ステップ・バイ・ステップ方式の自動交換機」が導入された\n    - 電話機にダイヤルが付いており、ダイヤル番号に応じて、その数字の回線に次々に接続していき、最終的に相手の電話機に回線がつながるという仕組み\n    - 次々に接続していくという動作からステップ・バイ・ステップという名称になった\n    - 1952 には、ステップ・バイ・ステップ交換機で市内通話は自動的につながるようになった\n      - しかし、市外通話は各地の自動交換機を経由するためには交換手が必要で時間がかり、また運用コストが高いというデメリットがあった\n  - 1955 年に「クロスバ交換機」が導入された\n    - 縦と横に張り巡らされた複数のバーがクロス(交差)して設置され、電話をかけると、ダイヤルされた電話番号の情報から各バーに付いている電磁石の磁力により縦と横のバーが接触し、相手に電話をつなぐ\n    - 市外通話も全自動化され、市外通話料金の自動記録も可能になった\n    - 1967 年には県庁所在地級の都市で利用されるようになり、1978 年には全国に広まった\n  - 1982 年には音声や制御信号をすべてデジタル化した「デジタル交換機」が導入された\n  - 2004 年には「IP 電話」サービスである「ひかり電話」が開始した\n    - IP 電話はインターネット網を利用し、電話は「SIP サーバ」で管理される\n\n## IP 電話\n\n- SIP(Session Initiation Protocol)\n  - 音声や動画のセッションを接続・切断する制御プロトコル\n  - 音声伝送などの機能は含まないため、他のプロトコルと組み合わせて利用することで、電話としての機能を実現する\n  - HTTP をベースとしている\n- ENUM(tElephone NUmber Mapping)\n  - DNS を用いて、業者の枠を超えたすべての電話番号とドメイン名を関連付ける\n  - 電話番号が ENUM に対応している必要がある\n  - ENUM の動作(一般固定電話から IP 電話につなげる場合)\n    - 一般固定電話から電話をかけると、公衆電話網を介し、ゲートウェイに制御が渡される\n    - ゲートウェイは、ENUM の DNS リゾルバに電話番号を渡し、SIP サーバと IP 電話の URI(URL)を得る\n    - ゲートウェイは、一般の DNS リゾルバに SIP サーバの URL を問い合わせ、SIP サーバの IP アドレスを得る\n    - ゲートウェイは SIP サーバにアクセスし、SIP サーバは IP 電話の URI をもとに DNS サーバへアクセスして IP 電話の IP アドレスを得る\n    - SIP サーバが IP 電話に対して呼制御を行う\n","UpdatedAt":"2021-03-15T21:55:34.6955016+09:00"},{"Text":"# Netowrk 系の用語メモ\n\n## 機器\n\n- L2Switch\n  - L2 レイヤ用のスイッチ\n  - 隣接ノードの Mac アドレスとポートの紐づきを管理するテーブルを持っており、特定 Mac アドレス宛てのパケットを対象ポートにフォワーディングする\n- L3Switch\n  - L3 レイヤ用のスイッチ\n  - IP によるルーティングを行う\n- Router\n  - L3 Switch の機能に加えて、Nat などの機能を備えたもの\n  - L3 Switch のことを Router とも呼んだりする\n\n## 基幹系\n\n- コアネットワーク、基幹通信網、バックボーン\n  - 通信網の中核にあたる部分を示す言葉\n- 携帯網\n  - 基地局\n    - 携帯と直接通信する無線通信装置\n    - 基地局から MME、SGW などへ転送される\n    - 基地局は以下のようなところに設置される\n      - 鉄塔の上、ビルやマンションの屋上に設置する広範囲タイプ\n      - 電柱に設置するタイプ、地下施設に設置する小規模タイプ\n      - 車、船、ドローンなどに設置されるタイプもある\n    - NB(Node B)\n      - 3G の一方式である W-CDMA の基地局のこと\n    - eNB(evolved Node B)\n      - LTE 基地局のこと\n  - MME(Mobility Management Entity)\n    - LTE の場合、携帯電話の制御信号のゲートウェイ\n  - SGW(Service Gateway)\n    - ユーザのデータそのもののゲートウェイ\n  - PGW(Packet data network Gateway)\n    - 外部であるインターネットに接続するためのゲートウェイ\n  - HSS(Home Subscriber Server)\n    - ユーザ情報のデータベース\n    - SIM の認証に利用される\n  - PCRF(Policy and Charging Rules Function)\n    - ネットワークポリシーや課金のルールをもつデータベース\n- TDM(Time Division Multiplexing)\n  - 時分割多重\n  - 複数の異なるデジタル信号を時間的に配列して、一つの伝送路で伝送を行うことができるようにする多重化の一方式\n- WDM(Wavelangth Division Multiplexing)\n  - 一本の光ケーブルの中に複数の波長の違う光を押し込むこと\n  - 光ケーブルは一本だが、擬似的に複数の光ケーブルがあるように扱う\n- SDH/SONET\n  - Synchronous Digital Hierachy/Synchronous Optical Network\n  - 通信網における階層的な伝送速度の標準\n    - SDH は ITU-T の国際標準\n    - SONET は米国 ANSI(米国規格協会)の標準\n- OTN(Optical Transport Network)\n  - イーサネットや SDH のバイト列を固定長に区切って、オーバヘッド(管理用情報)や誤り訂正機能を追加し、光増幅中継を繰り返す長距離伝送を実現する規格\n  - SDH と同様に TDM する機構も持っている\n\n## LAN 配線\n\n- 光トランシーバ・モジュール\n  - 光トランシーバは、電気信号と光信号を相互に変換してデータを送受信する\n  - SFP(Small Form-factor Pluggable)\n    - SFP は、イーサネットの 1000BASE-T または 1000BASE-X のいずれかで通信するための規格\n  - SFP+\n    - SFP+は、イーサネットの 10GBASE-R で通信するための規格\n  - CFP(C Form-factor Pluggable)、CFP2、CFP4\n    - CFP は 40GBASE-SR8、100GBASE-SR10 で通信するための規格\n  - QSFP28(Quad Small Form-factor Pluggable)\n    - 100GBASE-SR4 で通信するための規格\n- ケーブル\n  - SMF(Single Mode Fiber)\n    - 光の分散が小さいため長距離伝送に向いていおり、最大で 40Km 程度まで可能\n    - 芯経が小さいので接続のときの不整合による減衰が大きく、取扱は多少困難になる\n  - MMF(Multi Mode Fiber)\n    - MMF にはステップインデックス(SI)とグレーデッドインデックス(GI)がある\n    - SI は光の分散が大きく長距離電装屋高速伝送に向いていないが、価格は安価です\n    - GI は光の分散が比較的小さく、長距離伝送は 2km 程度まで可能で、伝送速度は最大 100Gbps まで可能\n    - OM1、OM2、OM3、OM4 と 4 種類ある\n      - 数字が大きければ、特性が良くなる\n      - OM3、OM4 は 10GbE 以上の高速伝送に最適化された MMF\n  - AOC\n    - アクティブ光ケーブル\n    - データセンタ内の限られた範囲の相互接続に使用される\n    - 内部は SMF もしくは MMF の光ファイバ\n    - プラガブル・トランシーバと同じコネクタを使用し、各ケーブル端で電気から光への変換を行う\n      - 40GE、100GE では QSFP 終端、10GE、25GE では SFP 終端する\n  - DAC\n    - 直結銅線ケーブル\n    - AOC と同様に、回線速度によって QSFP、SFP で終端される\n    - DAC に比較して、AOC ケーブルは伝送距離が長くて消費電力が少なく、軽量である\n      - しかし、コストは高く、光ファイバは銅線よりも損傷しやすいという難点もある\n- IDF、MDF\n  - IDF(Intermediate Distribution Flame)\n    - 各フロアの配線盤\n    - 各フロアに設置され、フロアに設置したケーブルを収容し、幹線ケーブルに接続する機器\n  - MDF(Main Distribution Flame)\n    - 主配線盤\n    - IDF の上流に接続し、企業やビル内のすべてのケーブルを収容する機器\n    - 機能は IDF と同じだが、MDF の方が規模が大きい\n- 用語メモ\n  - チャネル損失と最大距離\n    - チャネル損失: 機器間の最大損失値、この損失値を上回る損失になると伝送を保証できない\n    - 最大距離: 伝送を保証できる最大の距離\n    - 損失がチャネル損失値よりも少なく、最大距離よりも機器間の距離が短くないと伝送は保証されない\n- 参考\n  - 100 ギガ時代の LAN 配線\n    - https://toe.bbtower.co.jp/20170105/1187/\n    - https://toe.bbtower.co.jp/20170413/1513/\n    - https://toe.bbtower.co.jp/20170727/2144/\n\n## プロトコル\n\n- Segment Routing\n  - SRv6\n    - IPv6 のヘッダを利用して、SegmentRouting を実現する技術\n  - SRLB\n    - Segment Routing を利用した、ロードバランサ\n    - file:///C:/Users/owner/Downloads/2017-ICDCS-SRLBThePowerofChoicesinLoadBalancingwithSegmentRouting.pdf\n  - 参考\n    - https://www.janog.gr.jp/meeting/janog40/program/sr\n    - https://www.janog.gr.jp/meeting/janog40/application/files/2415/0051/7614/janog40-sr-kamata-takeda-00.pdf\n\n## 雑多\n\n- ADC(Application Delivery Controller)\n  - ロードバランサ、Firewall, TLS 終端などのフロントエンド前段の機能を兼ね備えた機器\n- パケット光統合トランスポート装置\n  - パケットスイッチ部と光スイッチ部を統合した装置\n  - 製品\n    - NEC SpectralWave DW7000\n- パッチパネル\n  - ラックの前部分についてるやつ\n- CLOS/EVPN + VXLAN\n- ポートミラーリング\n  - DDoS Detection\n  - FireWall\n- ポートチャネル\n  - 複数のポートでもう 1 台の装置と接続し、接続した複数のポートをチャネルグループという仮想リンクで 1 つに束ねる機能\n  - ポート帯域の拡張と冗長性を確保できる\n- Pod\n  - ネットワーク用語では、TOR スイッチを束ねた単位\n- STP(Spanning Tree Protocol)\n  - L2 の冗長構成において発生するループを、論理的に単一経路にして冗長化するためのプロトコル\n  - また、アクティブな単一経路が障害で使えなくなった場合、自動で別の経路に切り替える\n- VSS\n  - http://www.infraexpert.com/study/catalyst14.html\n- 渡り線（渡り配線）\n  - 冗長構成のために横のスイッチ同士(主に L2)をつなげるような配線のこと\n- HSRP(Hot Standby Routing Protocol)\n  - デフォルトゲートウェイを冗長化するためのシスコ独自のプロトコル\n  - 仮想 IP アドレスをデフォルトゲートウェイとして使用し、アクティブルータがダウンした場合にスタンバイルータでその仮想 IP を引き継ぐ\n- OSPF(Open Shortest Path First)\n  - リンクステート型ルーティングプロトコル\n- BGP(Border Gateway Protocol)\n  - AS Path Prepend\n    - ある IP へのルートが複数ある場合は、AS Path が少ないルートを優先するが、明示的に特定ルートへの AS Path 数を増やすことでそのルートの優先度を下げることができる\n    - メンテなどでトラフィックを他のノードへ寄せる時によく利用する\n  - Local Preference 属性\n    - Local Preference 属性を操作することで優先パスを操作することができる\n    - 内部 AS の隣接ノードに対して、外部 AS への優先パスを示す\n    - デフォルト値は 100 で、高い値を持つパスが優先される\n    - ベストパスの計算はパス数よりも Local Preference の方が優先される\n    - Switch の Graceful Shutdown 時には、Local Preference を下げて、自身への優先順位を下げてから Shutdown する\n  - MED 属性\n    - MED 属性を操作することで優先パスを操作することができる\n    - 外部 AS の隣接ノードに対して、自身の AS 内への優先パスを示す\n    - デフォルト値は 0 で、低い値を持つパスが優先される\n- BGP Flowspec\n  - サービスチェイニングするためのフロールールを BGP で設定する?\n- サービスチェイニング\n  - サービスプールを用意しておき、届いたパケットを種類によって各サービスに通して処理する\n  - パケットによってはファイアウォールや、DDoS フィルタを通したりする\n- ネットコード\n  - オンライン対戦などにおける物理的な通信遅延を、疑似的になくすための仕組み\n  - ディレイベース方式\n    - 通信遅延分だけフレームを遅らせて互いの操作を同期しながらゲームを進行する\n    - 通信遅延が大きくなるとその分同期のためにフレームも止まる\n  - ロールバックベース方式\n    - お互いにフレームの遅延なく入力を受け付けて、あとで計算しなおしてつじつまを合わせる\n    - 自分の画面には相手の予測動作を表示しておいて、数フレーム後に再計算してつじつまを合わせたりするので、相手が突然ワープしたりすることもある\n    - 予測は基本的には相手の直前の入力をそのまま反映させたりする\n  - 参考\n    - [『GUILTY GEAR XX ΛCORE PLUS R』にてオンライン対戦の遅延を改善する“期待の技術”テスト開始。ほぼ遅延なしの対戦を実現する「ロールバックネットコード」とは何なのか？](https://automaton-media.com/articles/newsjp/20201031-141954/)\n\n# ShowNet\n\n- 2018\n  - https://www.interop.jp/2018/images/shownet/shownet_topology.pdf\n","UpdatedAt":"2021-03-15T21:55:34.6975083+09:00"}],"IdPathMap":["README.md","bonding.md","datacenter.md","dhcp.md","dns.md","ipnetns.md","ipv6.md","loadbalancer.md","payment.md","security/README.md","security/basic.md","security/encription_by_openssl.md","security/ssh.md","security/tls.md","smtp_pop_imap.md","telephone_network.md","words.md"],"PathMap":{"README.md":0,"bonding.md":1,"datacenter.md":2,"dhcp.md":3,"dns.md":4,"ipnetns.md":5,"ipv6.md":6,"loadbalancer.md":7,"payment.md":8,"security/README.md":9,"security/basic.md":10,"security/encription_by_openssl.md":11,"security/ssh.md":12,"security/tls.md":13,"smtp_pop_imap.md":14,"telephone_network.md":15,"words.md":16}}